{
    "contents" : "#'  @description Derives Value-at-Risk using bivariate gaussian copula, for normal margins\n#'  @param quantile portfolio P/L qunatile, number\n#'  @param mu1 mean of first marginal P/L distribution, number\n#'  @param mu2 mean of second marginal P/L distribution, number\n#'  @param sigma1 standard deviation of first marginal P/L distribution, number, greater than zero\n#'  @param sigma2 standard deviation of second marginal P/L distribution, number, greater than zero\n#'  @param rho measure of correlation between two assets, number, must be in $[0;1)$\n#'  @param nsteps the number of steps used in the copula approximation. \n#'  Increase in the number of steps increases the accuracy, but also increases the computation time.\n#'  @param cl Value-at-Risk confidence level\n#'  @param bound number of portfolio sd from portfolio mean to search VaR by bisection, 3 by default\n#'  @param tol tolerance level to stop search VaR by bisection, 0.001 by default\n#'  @return list of two numbers: VaR estimated by copula and  VaR estimated by variance-covariance\n#'  @title Value-at-Risk with guass copula\nvar.copula.gauss <- function(mu1, mu2, sigma1, sigma2, rho, nsteps, cl,\n                             bound = 3, tol = 0.001){\n  if (!((sigma1 > 0) & (sigma2 > 0))){\n    stop('Standard deviation must be greater than zero.') \n  } \n  \n  if (!((rho >= 0) & (rho < 1))){\n    stop('Correlation coefficient rho must be in [0;1)')\n  }\n  \n  if (!(nsteps > 0)){\n    stop('Number of steps in copula approximation nsteps must be greater than zero')\n  }\n  \n  if (!((cl > 0) & (cl < 1))){\n    stop('Confidence level cl must be in (0;1)')\n  }\n  \n  p <- 1-cl\n  \n  p.mu <- mu1+mu2\n  cov.m <- matrix(c(sigma1^2, rho*sigma1*sigma2, rho*sigma1*sigma2, sigma2^2),\n                  nrow = 2, ncol = 2)\n  p.var <- as.numeric(c(1,1) %*% cov.m %*% c(1,1))\n  VaR.varcovar <- -p.mu-sqrt(p.var)*qnorm(p, mean = 0, sd = 1)\n  \n  L <- -p.mu-bound*sqrt(p.var)\n  fL <- cdfsum.copula.gauss(L, mu1, mu2, sigma1, sigma2, rho, nsteps) - p\n  \n  U <- -p.mu+bound*sqrt(p.var)\n  fU <- cdfsum.copula.gauss(U, mu1, mu2, sigma1, sigma2, rho, nsteps) - p\n  \n  if (sign(fL) == sign(fU)){\n    stop('Assumed bounds are not include answer')\n  }\n\n  while(U-L > tol){\n    x <- (L+U)/2\n    cum.prob <- cdfsum.copula.gauss(x, mu1, mu2, sigma1, sigma2, rho, nsteps)\n    fx <- cum.prob-p\n    if (sign(fx) == sign(fL)){\n      L <- x\n      fL <- fx\n    } else {\n      U <- x\n      fU <- fx\n    }\n  }\n  result <- list(copulaVaR = -x, variancecovarianceVaR = VaR.varcovar)\n  return(result)\n}",
    "created" : 1427323065133.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1967657909",
    "id" : "9EAD2854",
    "lastKnownWriteTime" : 1427323075,
    "path" : "~/git/VaRgcop/R/var.R",
    "project_path" : "R/var.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}